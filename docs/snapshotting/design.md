# General definition

VM Snapshotting is a mechanism through which a running microVM including the guest environment can be serialized and saved to an external medium in the form of a `snapshot`. This snapshot can be later used to restore a microVM with its guest workload at that particular point in time.

# Firecracker snapshots

Firecraker snapshotting will allow the creation of a microVM snapshot. This snapshot can be later loaded in a possibly different Firecracker process and the original guest workload will be simply resumed. Network connections state is not guaranteed to survive the process.

In order to make this possible, Firecracker snapshots aim to save full state of the following resources:
- guest memory,
- emulated HW state (both kvm and firecracker emulated hw),
- guest's storage disks' contents.

The current snapshot proposal aims for increased flexibility by independently generating and providing the state of components listed above. This means that taking a snapshot will result in multiple files that are composing the full microVM snapshot:
- guest memory file,
- vmm state file,
- zero or more disk files (depending on how many the guest had).

This design allows sharing any read-only resources (such as read-only disks or vmm state) between multiple microVMs to improve density.
When loading a snapshot, instead of loading the full contents from file to memory at resume time, Firecracker will create a `MAP_PRIVATE` mapping of the memory file resulting in runtime on-demand loading of memory pages. Any subsequent memory writes go to a copy-on-write anonymous memory mapping.

This has the advantage of **very fast snapshot loading** times, but comes with the cost of having to keep the _guest memory file_ around for the entire lifetime of the resumed microVM.

## Key Design Choices

- Fresh Firecracker microVMs will be booted using `anonymous` memory, while microVMs resumed from snapshot will load memory on-demand from the snapshot and copy-on-write to anonymous memory.
- *Resuming from a snapshot* is optimized for speed. *Taking a snapshot* will always involve synchronously writing dirty memory pages to snapshot file. Taking a snapshot of a fresh microVM running off non-file-backed anonymous memory, will result in full contents of guest memory being written to the snapshot.
- The snapshot operations have minimal requirements/dependencies on when/how they're used.
- The API calls exposing the snapshotting functionality have clear Prerequisites that describe the previously mentioned minimal requirements. Any flow that doesn't violate these prerequisites should be allowed and supported.
- _Memory file_ and _Vmm state file_ are generated by Firecracker on snapshot creation and the disk contents are flushed to their backing files. The disk files will be **managed by the user**; users need to externally back up their block devices backing files.

## API Definition
Supported individual operations are: `Pause`, `Resume`, `CreateFullSnapshot`, `CreateDiffSnapshot` and `LoadFullSnapshot`. To create a snapshot, pause the vm; you can resume it afterwards. Full snapshots always create a complete, resume-able snapshot of the current microVM state and memory. Diff snapshots save the current microVM state and the memory dirtied since the last snapshot (full or diff). Diff snapshots are not resume-able, but can be merged into a full snapshot using external (provided) tooling. The HTTP APIs are:

### `PUT /pause`: will attempt to pause the microVM
**Prerequisites**: Can be called at any time.
**Effects**:
- _on success_: microVM is guaranteed to be _Paused_.
- _on failure_: no side-effects.

**Return value**: Will report success if the microVM already was or, as an effect of this command, becomes _Paused_.
**Body**: None.

### `PUT /resume`: will attempt to resume the microVM;
**Prerequisites**: can be called at any time
**Effects**:
- _on success_: microVM is guaranteed to be _Running_;
- _on failure_: no side-effects.

**Return value**: will report success if the microVM already was or, as an effect of this command, becomes _Running_.
**Body**: None.

### `PUT /snapshot/create`: will attempt to create a full snapshot of the microVM
**Prerequisites**: can be called only when the microVM state is _Paused_
**Effects**:
- _on success_:
  - Two new files will be generated (with no side-effects to microVM state):
    - the vmm snapshot - file containing device model state and emulation state, and
    - the guest-mem full snapshot - file containing a full copy of the guest memory.
  - The block devices contents are flushed to their backing files. At this point, the user should externally back these up.
  - The generated snapshot files are immediately available to be used (current process releases ownership).
  - Will reset the dirtied page bitmap, will mark all pages clean (from a incremental snapshot point of view).
- _on failure_: No side-effects.
regardless of success/failure: will not influence state, will not stop or end the microVM (it can be used as before).

**Return value**: will report success if the snapshot files have been successfully generated, failure otherwise.
**Body**:
```yaml
SnapshotCreateConfig:
  type: object
  required:
    - snapshot_path
    - mem_file_path
  properties:
    version:
      type: integer
      minimum: TBD
      maximum: TBD
      description: Optional field for snapshot format version. If omitted
                   Firecracker will default to creating a snapshot with the
                   current version.
    snapshot_path:
      type: string
      description: Path to file which will be populated with the vmm state.
    mem_file_path:
      type: string
      description: Path to file which will be populated with the guest memory.
                   The file will contain a copy of the guest memory or copies
                   of just the dirtied pages, depending on which URL this
                   object is used.
```

### `PUT /snapshot/create-diff`: will attempt to create a "diff" snapshot of the microVM

**Prerequisites**: can be called only when the microVM state is *Paused.*
**Effects:**
- _on success_:
  - Two new files will be generated (with no side-effects to microVM state):
    - the vmm snapshot - file containing device model state and emulation state, and
    - the guest-mem diff snapshot - file containing a **diff copy** of the guest memory - the diff is consisted of the memory pages which have been dirtied since the last snapshot creation or since the creation of the microVM, whichever of these events was the most recent.
  - The block devices contents are flushed to their backing files. At this point, the user should externally back these up.
  - The generated snapshot files are immediately available to be used (current process releases ownership).
  - Will reset the dirtied page bitmap, will mark all pages *clean* (from a incremental snapshot point of view).
- _on failure_: No side-effects.
- _regardless of success/failure_: Will **not** influence state, will **not **stop or end the microVM (it can be used as before).

**Return value:** will report success if the snapshot files have been successfully generated, failure otherwise.
**Body:** Yaml definition: same `SnapshotCreateConfig` body as used in `PUT /snapshot/create`.

### **`PUT /snapshot/load`: will attempt to load a full snapshot of the microVM**

**Prerequisites**:
- Does **not** work with **diff** snapshots.
- Can be called only before configuring any resources (other than the `Logger`) for this microVM, or in other words, should be called in a fresh Firecracker process.

**Effects:**
- _on success_:
  - Complete microVM state will be loaded from snapshot into this Firecracker process.
  - Will also reset the dirtied page bitmap, will make all pages *clean* (from a incremental snapshot point of view).
  - Loaded microVM is now in the *Paused* state and needs to be resumed for it to run.
  - *The guest-mem snapshot file* from which this microVM was resumed **must not change** throughout the lifetime of this microVM. Since the guest in this microVM will load pages from the file on demand, this Firecracker process should be considered to have a shared-read-lock on the file. Any external writes to the file can lead to microVM guest *Undefined Behavior.*
  - *The vmm snapshot file* used to load from, is released and no longer used by this process.
- _on failure_: will report the encountered error, then end this Firecracker process (as it might be in an invalid state).

**Return value:** Will report success if the microVM was successfully loaded, failure otherwise.
**Body:**
```yaml
SnapshotLoadConfig:
  type: object
  required:
    - snapshot_path
    - mem_file_path
  properties:
    snapshot_path:
      type: string
      description: Path to file which contains the vmm state to be loaded.
    mem_file_path:
      type: string
      description: Path to file which contains the guest memory to be loaded.
                   This file should not be externally changed for the entire
                   lifetime of the microVM to be loaded.
```

## Snapshot Format

We will use **serde** as a serialization framework since it is a well maintained project with a large community. Serde defines a set of primitives and provides an interface for serializers to implement. Our approach is to build a custom serde serializer that meets the following criteria:

* Performance: Serialization/deserialization should be fast and the snapshot small in size.
* Code should be well-tested and documented.
* Implementing cross-version snapshot restore should be easy to do.
* The format should follow a clearly defined specification.
* The format should have support in other languages, so tooling can be built around the snapshot format.
* There should either be a large community that provides good support, or we should own it.

### Current favorites

1. Extend the existing serde compliant **bincode** serializer to match our requirements.
2. Implement a **custom CBOR** serializer. It will require more work than any of the other approaches but this can be a very good option as we only keep serde as a dependency and there are no external risks factors for breaking changes in the snapshot format.

### We also looked at these other options

1. **Serde-bincode**. Use the upstream [`bincode`](https://crates.io/crates/bincode) crate and add minimal versioning support via using a snapshot translator.
2. **Serde-cbor**. Use the upstream [`serde-cbor`](https://crates.io/crates/serde_cbor) crate and the [CBOR](https://tools.ietf.org/html/rfc7049) format.
    It combines the strong type definition specific to JSON with a binary format for small snapshot sizes. Does not have out-of-the-box support for versioning. Early experimentation indicates potential need for upstream bugfixes.
3. **Serde-protobuf**. We haven't invested much in researching protobuf, but it doesn't seem a good choice. It looks complicated to implement in Firecracker as the [`serde-protobuf` crate](https://crates.io/crates/serde-protobuf) is in its early stages. Another option is to directly use [`rust-protobuf`](https://github.com/stepancheg/rust-protobuf).

|Format    |Performance    |Quality    |Versioning    |Spec    |Tooling    |Community    |
|---    |---    |---    |---    |---    |---    |---    |
|Bincode    |++    |-    |-    |-    |-    |+    |
|CBOR    |+?    |+    |-    |+    |+    |-    |
|Protobuf    |+?    |+?    |?    |+    |++    |--    |
|Custom    |++    |+    |+    |+    |-    |N/A    |

### Snapshot versioning

#### Requirements

* Firecracker snapshots need to be backwards compatible, meaning that any Firecracker version **N+c** can successfully load a snapshot created by Firecracker version **N.**
* Firecracker version N + c must be able create snapshots with any version in [N, N + c].

Snapshots are created or restored from or by Firecracker using the specific APIs listed earlier. Each new version of Firecracker is able to load a snapshot that was created by an older version of Firecracker. Block devices and memory files do not require versioning, only the VM state file does as it contains internal state structures for device emulation, vCPUs and others that will change format as we continue to improve Firecracker.

Each snapshot contains a version number in the VM state file which identifies the Firecracker version used to create that snapshot.

Firecracker will implement a **version translator** to support restore from older versions.

#### Creating a snapshot

If the user specifies a version the new snapshot will be saved as that version, otherwise it will be saved as the same version of the running Firecracker.

The user creating the snapshot will have to own and handle the block device file components of the snapshot.

#### Restoring a snapshot

There are 4 cases :

1. Firecracker version == snapshot version. Firecracker loads the snapshot and does not need to perform any translation.
2. Firecracker version N > snapshot version M. Firecracker will use some TBD/design-in-progress version translation mechanism to build state of version N from snapshot of version M.
3. Firecracker version N, snapshot N + 1. Firecracker will not be able to restore from a future version snapshot.
4. Firecracker version N + c + 1, snapshot N. Firecracker will not be able to restore from the snapshot as we offer support to restore from the last **c** versions.

#### Open items

What is the value of **c** (maximum number of older versions that we can restore from/snapshot to from the current version)?

## Snapshot Tools

To enable users to benefit from snapshotting, we will to provide the following tools:

* _Diff Compactor_: A simple offline tool that takes in one "base" snapshot and one or more successive snapshot diffs, and creates a single snapshot that Firecracker can restore from.

