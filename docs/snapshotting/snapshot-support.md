# Firecracker Snapshotting

## What is microVM snapshotting?

MicroVM snapshotting is a mechanism through which a running microVM and its
resources can be serialized and saved to an external medium in the form of a
`snapshot`. This snapshot can be later used to restore a microVM with its
guest workload at that particular point in time.

## Snapshotting in Firecracker

A Firecracker microVM snapshot can be used for loading it later in a different
Firecracker process, and the original guest workload is being simply resumed.
It is not guaranteed though that the state of the network connections survives
the process.

In order to make restoring possible, Firecracker snapshots save the full state
of the following resources:
- the guest memory,
- the emulated HW state (both KVM and Firecracker emulated HW).

The state of the components listed above is generated independently, which brings
flexibility to our snapshotting support. This means that taking a snapshot results
in multiple files that are composing the full microVM snapshot:
- the guest memory file,
- the microVM state file,
- zero or more disk files (depending on how many the guest had; these are
  **managed by the users**, which means they need to externally back up their
  block devices backing files).

The design allows sharing of memory pages and read only disks between multiple
microVMs. When loading a snapshot, instead of loading at resume time the full
contents from file to memory, Firecracker creates a
[MAP_PRIVATE mapping](http://man7.org/linux/man-pages/man2/mmap.2.html) of the
memory file, resulting in runtime on-demand loading of memory pages. Any subsequent
memory writes go to a copy-on-write anonymous memory mapping.
This has the advantage of very fast snapshot loading times, but comes with the cost
of having to keep the guest memory file around for the entire lifetime of the
resumed microVM.

*Note*: Snapshotting is currently supported only on `x86_64` machines.

## Firecracker Snapshotting characteristics

- Fresh Firecracker microVMs are booted using `anonymous` memory, while microVMs
  resumed from snapshot load memory on-demand from the snapshot and copy-on-write
  to anonymous memory.
- Resuming from a snapshot is optimized for speed, while taking a snapshot involves
  some extra CPU cycles for synchronously writing dirty memory pages to the memory
  snapshot file. Taking a snapshot of a fresh microVM, on which dirty pages tracking
  is not enabled, results in the full contents of guest memory being written to the
  snapshot.
- The _memory file_ and _microVM state file_ are generated by Firecracker on snapshot
  creation, and the disk contents are flushed to their backing files.  
- The API calls exposing the snapshotting functionality have clear **Prerequisites**
  that describe the requirements on when/how they should be used.
 
## Snapshot versioning

Firecracker snapshotting implementation offers support for microVM versioning
(`cross-version snapshots`) in the following contexts:
- saving snapshots at older versions (being able to create a snapshot with any version
in the `[N, N + o]` interval, while being in Firecracker version `N+o`),
- loading snapshots from older versions (being able to load a snapshot created by any
Firecracker version in the `[N, N + o]` interval, in a Firecracker version `N+o`).

The design supports an unlimited number of versions, the value of `o` (maximum number
of older versions that we can restore from / save a snapshot to, from the current
version) will be defined later.

## Snapshot API

Firecracker exposes the following APIs for manipulating snapshots: `Pause`, `Resume`
and `CreateSnapshot` can be called only after booting the microVM, while `LoadSnapshot`
is allowed only before boot.

### Pausing the microVM

To create a snapshot, first you have to pause the running microVM and its vCPUs with
the following API command:

```bash
curl --unix-socket /tmp/firecracker.socket -i \
    -X PATCH 'http://localhost/vm' \
    -H 'Accept: application/json' \
    -H 'Content-Type: application/json' \
    -d '{
            "state": "Paused"
    }'
```

**Prerequisites**: The microVM is booted.
                   Successive calls of this request keep the microVM in the `Paused`
                   state.
**Effects**:
- _on success_: microVM is guaranteed to be `Paused`.
- _on failure_: no side-effects.

## Creating snapshots

Now that the microVM is paused, you can create a snapshot. Full snapshots always
create a complete, resumeable snapshot of the current microVM state and memory.
`Diff` snapshots functionality is not yet supported.

### Creating full snapshots

For creating a full snapshot, you can use the following API command:

```bash
curl --unix-socket /tmp/firecracker.socket -i \
    -X PUT 'http://localhost/snapshot/create' \
    -H  'Accept: application/json' \
    -H  'Content-Type: application/json' \
    -d '{
            "snapshot_type": "Full",
            "snapshot_path": "./snapshot_file",
            "mem_file_path": "./mem_file",
            "version": "0.23.0"
    }'
```

Details about the required and optional fields can be found in the
[swagger definition](../../src/api_server/swagger/firecracker.yaml).
*Note*: If the files indicated by `snapshot_path` and `mem_file_path` don't exist at
        the specified paths, then they will be created right before generating the
        snapshot.

**Prerequisites**: The microVM is `Paused`.
**Effects**:
- _on success_:
  - The file indicated by `snapshot_path` (e.g. `/path/to/snapshot_file`) contains the
    devices' model state and emulation state. The one indicated by `mem_file_path`
    (e.g. `/path/to/mem_file`) contains a full copy of the guest memory.
  - The block devices contents are flushed to their backing files. At this point, these
    should be backed up externally by the user. The generated snapshot files are
    immediately available to be used (current process releases ownership).
  - If diff snapshots were enabled, the snapshot creation resets then the dirtied page
    bitmap and marks all pages clean (from a diff snapshot point of view).

If a `version` is specified, the new snapshot is saved at that version, otherwise
it will be saved at the same version of the running Firecracker. The version is only
used for the microVM state file as it contains internal state structures for device
emulation, vCPUs and others that can change their format from a Firecracker version
to another. Versioning is not required for the block and memory files. The separate
block device file components of the snapshot have to be handled by the user.

- _on failure_: no side-effects.

### Creating diff snapshots

Not yet supported.

### Resuming the microVM

You can resume the microVM by sending the following API command:

```bash
curl --unix-socket /tmp/firecracker.socket -i \
    -X PATCH 'http://localhost/vm' \
    -H 'Accept: application/json' \
    -H 'Content-Type: application/json' \
    -d '{
            "state": "Resumed"
    }'
```

**Prerequisites**: The microVM is `Paused`.
                   Successive calls of this request are ignored (microVM remains
                   in the running state).
**Effects**:
- _on success_: microVM is guaranteed to be `Resumed`.
- _on failure_: no side-effects.

## Loading snapshots

If you want to load a snapshot, you can do that only **before** the microVM is configured
(the only resources that can be configured prior are the Logger and the Metrics systems)
by sending the following API command:

```bash
curl --unix-socket /tmp/firecracker.socket -i \
    -X PUT 'http://localhost/snapshot/load' \
    -H  'Accept: application/json' \
    -H  'Content-Type: application/json' \
    -d '{
            "snapshot_path": "./snapshot_file",
            "mem_file_path": "./mem_file",
            "enable_diff_snapshots": true
    }'
```

Details about the required and optional fields can be found in the
[swagger definition](../../src/api_server/swagger/firecracker.yaml).

**Prerequisites**: A full memory snapshot and a microVM state file **must** be provided.
                   The disk backing files, network interfaces backing TAPs and/or vsock
                   backing socket that were used for the original microVM's configuration
                   should be set up and accessible to the new Firecracker process (in
                   which the microVM is resumed). These host-resources need to be
                   accessible at the same relative paths to the new Firecracker process
                   as they were to the original one.
**Effects:**
- _on success_:
  - The complete microVM state is loaded from snapshot into the current Firecracker
    process.
  - It then resets the dirtied page bitmap and marks all pages clean (from a diff
    snapshot point of view).
  - The loaded microVM is now in the `Paused` state, so it needs to be resumed for it
    to run.
  - The memory file pointed by `mem_file_path` **must** be considered immutable from
    Firecracker and host point of view. It backs the guest OS memory for read access
    through the page cache. External modification to this file corrupts the guest
    memory and leads to undefined behavior.
  - The file indicated by `snapshot_path`, that is used to load from, is released and no
    longer used by this process.
  - If `enable_diff_snapshots` is set, then diff snapshots can be taken afterwards.
- _on failure_: A specific error is reported and then the current Firecracker process
                is ended (as it might be in an invalid state).

*Notes*:
`enable_diff_snapshots` on the snapshot load API is currently just an equivalent for
`track_dirty_pages` from the vm config API. Actual diff snapshots are not yet supported.
Keeping the name snapshot-related so that it will not be an API breaking change when
we add the diff snapshots support.

With these in mind, some possible snapshotting scenarios are the following:
- `Boot from a fresh microVM` -> `Pause` -> `Create snapshot` -> `Resume` -> `Pause` ->
  `Create snapshot` -> ... ;
- `Boot from a fresh microVM` -> `Pause` -> `Create snapshot` -> `Resume` -> `Pause` ->
  `Resume` -> ... -> `Pause` -> `Create snapshot` -> ... ;
- `Load snapshot` -> `Resume` -> `Pause` -> `Create snapshot` -> `Resume` -> `Pause` ->
  `Create snapshot` -> ... ;
- `Load snapshot` -> `Resume` -> `Pause` -> `Create snapshot` -> `Resume` -> `Pause` ->
  `Resume` -> ... -> `Pause` -> `Create snapshot` -> ... ;

### Timekeeping and snapshots

It is also worth knowing, a microVM that is restored from snapshot will be resumed with
the guest OS wall-clock continuing from the moment of the snapshot creation. For this
reason, the wall-clock should be updated to the current time, on the guest-side.
More details on how you could do this can be found at a
[related FAQ](../../FAQ.md#my-guest-wall-clock-is-drifting-how-can-i-fix-it).
